{"version":3,"file":"streaming.js","mappings":"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","sources":["src://tavern_helper_template/util/script.ts","src://tavern_helper_template/util/common.ts","src://tavern_helper_template/external var \"Vue\"","src://tavern_helper_template/util/streaming.ts","webpack://tavern_helper_template/util/iframe_srcdoc.html?c178"],"sourcesContent":["import iframe_srcdoc from './iframe_srcdoc.html';\n\nexport async function loadReadme(url: string): Promise<boolean> {\n  const readme = await fetch(url);\n  if (!readme.ok) {\n    return false;\n  }\n  const readme_text = await readme.text();\n  replaceScriptInfo(readme_text);\n  return true;\n}\n\nexport function teleportStyle(\n  append_to: JQuery.Selector | JQuery.htmlString | JQuery.TypeOrArray<Element | DocumentFragment> | JQuery = 'head',\n): { destroy: () => void } {\n  const $div = $(`<div>`)\n    .attr('script_id', getScriptId())\n    .append($(`head > style`, document).clone())\n    .appendTo(append_to);\n\n  return {\n    destroy: () => $div.remove(),\n  };\n}\n\nexport function createScriptIdIframe(): JQuery<HTMLIFrameElement> {\n  return $(`<iframe>`).attr({\n    script_id: getScriptId(),\n    frameborder: 0,\n    srcdoc: iframe_srcdoc,\n  }) as JQuery<HTMLIFrameElement>;\n}\n\nexport function createScriptIdDiv(): JQuery<HTMLDivElement> {\n  return $('<div>').attr('script_id', getScriptId()) as JQuery<HTMLDivElement>;\n}\n\nexport function reloadOnChatChange(): EventOnReturn {\n  let chat_id = SillyTavern.getCurrentChatId();\n  return eventOn(tavern_events.CHAT_CHANGED, new_chat_id => {\n    if (chat_id !== new_chat_id) {\n      chat_id = new_chat_id;\n      window.location.reload();\n    }\n  });\n}\n\nexport function registerAsUniqueScript(id: string): {\n  unregister: () => void;\n  getPreferredScriptId: () => string | undefined;\n  listenPreferenceState: (callback: (perferred_script_id: string) => void) => EventOnReturn;\n} {\n  const script_id = getScriptId();\n  const path = `th_unique_check.${id}`;\n\n  const getPreferredScriptId = () => {\n    const registered_scripts = _.get(window.parent, path, new Set<string>());\n    return _($('#tavern_helper').find('div[data-script-id]').toArray())\n      .map(element => String($(element).attr('data-script-id')))\n      .filter(element => registered_scripts.has(element))\n      .last();\n  };\n\n  _.update(window.parent, path, (value: Set<string> | undefined) => {\n    if (value === undefined) {\n      return new Set([script_id]);\n    }\n    value.add(script_id);\n    return value;\n  });\n  eventEmit(path, getPreferredScriptId());\n\n  return {\n    unregister: () => {\n      _.update(window.parent, path, (value: Set<string> | undefined) => {\n        if (value !== undefined) {\n          value.delete(script_id);\n        }\n        return value;\n      });\n      eventEmit(path, getPreferredScriptId());\n    },\n    getPreferredScriptId,\n    listenPreferenceState: (callback: (enabled_script_id: string) => void) => eventOn(path, callback),\n  };\n}\n","import { compare } from 'compare-versions';\nimport JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { toDotPath } from 'zod/v4/core';\n\nexport function assignInplace<T>(destination: T[], new_array: T[]): T[] {\n  destination.length = 0;\n  destination.push(...new_array);\n  return destination;\n}\n\nexport function chunkBy<T>(array: T[], predicate: (lhs: T, rhs: T) => boolean): T[][] {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const chunks: T[][] = [[array[0]]];\n  for (const [lhs, rhs] of _.zip(_.dropRight(array), _.drop(array))) {\n    if (predicate(lhs!, rhs!)) {\n      chunks[chunks.length - 1].push(rhs!);\n    } else {\n      chunks.push([rhs!]);\n    }\n  }\n  return chunks;\n}\n\nexport function regexFromString(input: string, replace_macros?: boolean): RegExp | null {\n  if (!input) {\n    return null;\n  }\n  const makeRegex = (pattern: string, flags: string) => {\n    if (replace_macros) {\n      pattern = substitudeMacros(pattern);\n    }\n    return new RegExp(pattern, flags);\n  };\n  try {\n    const match = input.match(/\\/(.+)\\/([a-z]*)/i);\n    if (!match) {\n      return makeRegex(_.escapeRegExp(input), 'i');\n    }\n    if (match[2] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(match[3])) {\n      return makeRegex(input, 'i');\n    }\n    let flags = match[2] ?? '';\n    _.pull(flags, 'g');\n    if (flags.indexOf('i') === -1) {\n      flags = flags + 'i';\n    }\n    return makeRegex(match[1], flags);\n  } catch {\n    return null;\n  }\n}\n\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function checkMinimumVersion(expected: string, title: string) {\n  if (compare(await getTavernHelperVersion(), expected, '<')) {\n    toastr.error(`'${title}' 需要酒馆助手版本 >= '${expected}'`, '版本不兼容');\n  }\n}\n\nexport function prettifyErrorWithInput(error: z.ZodError) {\n  return _([...error.issues])\n    .sortBy(issue => issue.path?.length ?? 0)\n    .flatMap(issue => {\n      const lines = [`✖ ${issue.message}`];\n      if (issue.path?.length) {\n        lines.push(`  → 路径: ${toDotPath(issue.path)}`);\n      }\n      if (issue.input !== undefined) {\n        lines.push(`  → 输入: ${JSON.stringify(issue.input)}`);\n      }\n      return lines;\n    })\n    .join('\\n');\n}\n\nexport function literalYamlify(value: any) {\n  return YAML.stringify(value, { blockQuote: 'literal' });\n}\n\nexport function parseString(content: string): any {\n  let parsed: unknown;\n  try {\n    parsed = YAML.parseDocument(content, { merge: true }).toJS();\n  } catch (yaml_error) {\n    try {\n      // eslint-disable-next-line import-x/no-named-as-default-member\n      parsed = JSON5.parse(content);\n    } catch (json5_error) {\n      try {\n        parsed = JSON.parse(jsonrepair(content));\n      } catch (json_error) {\n        const toError = (error: unknown) => (error instanceof Error ? error.message : String(error));\n        throw new Error(\n          literalYamlify({\n            ['要解析的字符串不是有效的 YAML/JSON 格式']: {\n              字符串内容: content,\n              YAML错误信息: toError(yaml_error),\n              JSON5错误信息: toError(json5_error),\n              尝试修复JSON时的错误信息: toError(json_error),\n            },\n          }),\n        );\n      }\n    }\n  }\n  return parsed;\n}\n\nexport function getComplementString(string: string) {\n  const encoder = new TextEncoder();\n  const bytes = encoder.encode(string);\n\n  const complemented = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    complemented[i] = 0xff - bytes[i];\n  }\n\n  let hex = '';\n  for (let i = 0; i < complemented.length; i++) {\n    const h = complemented[i].toString(16).padStart(2, '0');\n    hex += h;\n  }\n  return hex;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = Vue;","import { createScriptIdDiv, createScriptIdIframe, teleportStyle } from '@util/script';\nimport { uuidv4 } from './common';\nexport function injectStreamingMessageContext() {\n    return readonly(inject('streaming_message_context'));\n}\n/**\n * 将组件作为流式楼层界面挂载到酒馆各个楼层, 替换掉酒馆原生的楼层正文显示.\n *\n * 方案是隐藏酒馆原来的楼层文本, 而在它下方插入一个类名有 `mes_streaming` 的 DOM:\n *   - `options.host==='iframe'` 则插入的是 iframe, 其内 contentDocument.body 作为组件的挂载点\n *     - 样式将与酒馆原生界面隔离\n *     - 组件内可以使用 tailwindcss\n *   - `options.host==='div'` 则插入的是 div, 它直接作为组件的挂载点\n *     - 将会继承酒馆样式\n *     - 禁止使用 mes_text 类名, 它会让酒馆的编辑楼层功能不可用\n *     - 组件内不能使用 tailwindcss, 因为会影响酒馆其他部分的样式\n *     - 你也许会用到 `@types/function/displayed_message.d.ts` 中的 `formatAsDisplayedMessage` 来格式化消息内容, 并用 `.replaceAll('mes_text', 'mes_streaming')` 来为格式化后内容适配样式\n *\n * @param creator 创建流式界面的组件, 函数内可以用 `.use` 安装依赖或执行其他逻辑\n * @param options 可选选项\n *   - `host`: 宿主, 默认为 `'iframe'`, 因为 `'iframe'` 能隔离样式, 更方便做复杂界面\n *   - `filter`: 楼层过滤器. 如果设置, 则只有符合条件的楼层才会被挂载流式楼层界面\n *   - `prefix`: 组件的唯一标识符, 默认随机生成一个. 函数产生的流式楼层界面会共享这个 `prefix`, 并将 `host` DOM 的 id 设置成 `${prefix}-${message_id}`.\n * @returns 卸载流式楼层界面的函数\n */\nexport function mountStreamingMessages(creator, options = {}) {\n    const { host = 'iframe', filter, prefix = uuidv4() } = options;\n    const states = new Map();\n    let has_stoped = false;\n    const destroyIfInvalid = (message_id) => {\n        const min_message_id = Number($('#chat > .mes').first().attr('mesid'));\n        if (!_.inRange(message_id, min_message_id, SillyTavern.chat.length)) {\n            states.get(message_id)?.destroy();\n            return true;\n        }\n        return false;\n    };\n    const destroyAllInvalid = () => {\n        states.keys().forEach(message_id => destroyIfInvalid(message_id));\n    };\n    const renderOneMessage = async (message_id, stream_message) => {\n        if (has_stoped) {\n            return;\n        }\n        if (destroyIfInvalid(message_id)) {\n            return;\n        }\n        const message = stream_message ?? getChatMessages(message_id)[0].message ?? '';\n        if (filter && !filter(message_id, message)) {\n            states.get(message_id)?.destroy();\n            return;\n        }\n        const $message_element = $(`.mes[mesid='${message_id}']`);\n        const $mes_text = $message_element.find('.mes_text').addClass('hidden!');\n        $message_element.find('.TH-streaming').addClass('hidden!');\n        let $host = $message_element.find(`#${prefix}-${message_id}`);\n        if ($host.length > 0) {\n            const state = states.get(message_id);\n            if (state) {\n                state.data.message = message;\n                state.data.during_streaming = Boolean(stream_message);\n                return;\n            }\n        }\n        states.get(message_id)?.destroy();\n        $host.remove();\n        let $mes_streaming = $message_element.find('.mes_streaming');\n        if ($mes_streaming.length === 0) {\n            $mes_streaming = $('<div class=\"mes_streaming\">')\n                .css({\n                'font-weight': '500',\n                'line-height': 'calc(var(--mainFontSize) + .5rem)',\n                'max-width': '100%',\n                'overflow-wrap': 'anywhere',\n                padding: 'calc(var(--mainFontSize) * 0.8) 0 0 0',\n            })\n                .insertAfter($mes_text);\n        }\n        $host = (host === 'iframe' ? createScriptIdIframe().addClass('w-full') : createScriptIdDiv())\n            .attr('id', `${prefix}-${message_id}`)\n            .appendTo($mes_streaming);\n        const data = reactive({\n            prefix,\n            host_id: `${prefix}-${message_id}`,\n            message_id,\n            message,\n            during_streaming: Boolean(stream_message),\n        });\n        const app = creator().provide('streaming_message_context', data);\n        if (host === 'iframe') {\n            $host.on('load', function () {\n                teleportStyle(this.contentDocument.head);\n                app.mount(this.contentDocument.body);\n            });\n        }\n        else {\n            app.mount($host[0]);\n        }\n        const observer = new MutationObserver(() => {\n            const $edit_textarea = $('#chat').find('#curEditTextarea');\n            if ($edit_textarea.parent().is($mes_text)) {\n                $mes_text.removeClass('hidden!');\n                $host.addClass('hidden!');\n            }\n            else if ($edit_textarea.length === 0) {\n                $mes_text.addClass('hidden!');\n                $message_element.find('.TH-streaming').addClass('hidden!');\n                $host.removeClass('hidden!');\n            }\n        });\n        observer.observe($mes_text[0], { childList: true });\n        states.set(message_id, {\n            app,\n            data,\n            destroy: () => {\n                const $th_streaming = $message_element.find('.TH-streaming');\n                if ($th_streaming.length > 0) {\n                    $th_streaming.removeClass('hidden!');\n                }\n                else {\n                    $mes_text.removeClass('hidden!');\n                }\n                app.unmount();\n                $host.remove();\n                if ($mes_streaming.children().length === 0) {\n                    $mes_streaming.remove();\n                }\n                observer.disconnect();\n                states.delete(message_id);\n            },\n        });\n    };\n    const renderAllMessage = async (options = {}) => {\n        if (has_stoped) {\n            return;\n        }\n        if (options.destroy_all) {\n            states.forEach(({ destroy }) => destroy());\n        }\n        else {\n            destroyAllInvalid();\n        }\n        await Promise.all($('#chat')\n            .children(\".mes[is_user='false'][is_system='false']\")\n            .map(async (_index, node) => {\n            const message_id = Number($(node).attr('mesid') ?? 'NaN');\n            if (!isNaN(message_id)) {\n                await renderOneMessage(message_id);\n                if (options.trigger_event) {\n                    eventEmit(tavern_events.CHARACTER_MESSAGE_RENDERED, message_id, 'rerender');\n                }\n            }\n        }));\n    };\n    const stop_list = [];\n    const scopedEventOn = (event, listener, first) => {\n        stop_list.push(first ? eventMakeFirst(event, errorCatched(listener)).stop : eventOn(event, errorCatched(listener)).stop);\n    };\n    scopedEventOn('chatLoaded', () => {\n        renderAllMessage({ destroy_all: true });\n    });\n    scopedEventOn(tavern_events.CHARACTER_MESSAGE_RENDERED, message_id => {\n        destroyAllInvalid();\n        renderOneMessage(message_id);\n    }, true);\n    [tavern_events.MESSAGE_EDITED, tavern_events.MESSAGE_DELETED].forEach(event => scopedEventOn(event, message_id => {\n        destroyAllInvalid();\n        states.get(message_id)?.destroy();\n        renderOneMessage(message_id);\n    }));\n    scopedEventOn(tavern_events.MESSAGE_DELETED, () => setTimeout(errorCatched(renderAllMessage), 1000));\n    scopedEventOn(tavern_events.STREAM_TOKEN_RECEIVED, message => {\n        renderOneMessage(Number($('#chat').children('.mes.last_mes').attr('mesid')), message);\n    });\n    if (host === 'div') {\n        stop_list.push(teleportStyle().destroy);\n    }\n    renderAllMessage({ trigger_event: true });\n    return {\n        unmount: () => {\n            const $th_streaming = $('#chat').find('.TH-streaming');\n            if ($th_streaming.length > 0) {\n                $th_streaming.removeClass('hidden!');\n            }\n            else {\n                $('chat').find('.mes_text').removeClass('hidden!');\n            }\n            states.forEach(({ destroy }) => destroy());\n            stop_list.forEach(stop => stop());\n            has_stoped = true;\n        },\n    };\n}\n","// Module\nvar code = `<head> <link rel=\"stylesheet\" href=\"https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css\"> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/gh/n0vi028/JS-Slash-Runner/lib/tailwindcss.min.js\">${\"<\" + \"/script\"}> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/npm/jquery\">${\"<\" + \"/script\"}> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/npm/jquery-ui/dist/jquery-ui.min.js\">${\"<\" + \"/script\"}> <link rel=\"stylesheet\" href=\"https://testingcf.jsdelivr.net/npm/jquery-ui/themes/base/theme.min.css\"/> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/npm/jquery-ui-touch-punch\">${\"<\" + \"/script\"}> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/npm/lodash\">${\"<\" + \"/script\"}> ${\"<\" + \"script\"} src=\"https://testingcf.jsdelivr.net/gh/n0vi028/JS-Slash-Runner/src/iframe/adjust_iframe_height.js\">${\"<\" + \"/script\"}> <style>*,::after,::before{box-sizing:border-box}body,html{margin:0!important;padding:0;overflow:hidden!important;max-width:100%!important}</style> </head> `;\n// Exports\nexport default code;"],"names":["teleportStyle","append_to","$div","$","attr","getScriptId","append","document","clone","appendTo","destroy","remove","uuidv4","replace","c","r","Math","random","toString","Vue","injectStreamingMessageContext","readonly","inject","mountStreamingMessages","creator","options","host","filter","prefix","states","Map","has_stoped","destroyIfInvalid","message_id","min_message_id","Number","first","_","inRange","SillyTavern","chat","length","get","destroyAllInvalid","keys","forEach","renderOneMessage","async","stream_message","message","getChatMessages","$message_element","$mes_text","find","addClass","$host","state","data","during_streaming","Boolean","$mes_streaming","css","padding","insertAfter","script_id","frameborder","srcdoc","reactive","host_id","app","provide","on","this","contentDocument","head","mount","body","observer","MutationObserver","$edit_textarea","parent","is","removeClass","observe","childList","set","$th_streaming","unmount","children","disconnect","delete","renderAllMessage","destroy_all","Promise","all","map","_index","node","isNaN","trigger_event","eventEmit","tavern_events","CHARACTER_MESSAGE_RENDERED","stop_list","scopedEventOn","event","listener","push","eventMakeFirst","errorCatched","stop","eventOn","MESSAGE_EDITED","MESSAGE_DELETED","setTimeout","STREAM_TOKEN_RECEIVED"],"ignoreList":[],"sourceRoot":""}