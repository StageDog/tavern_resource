{"version":3,"file":"index.js","mappings":"wUAAA,MAAM,EAA+BA,ECI/BC,EAAW,EAAAD,EACZE,OAAO,CACR,KAAM,EAAAF,EAAEG,SAASC,QAAQ,OACzB,KAAM,EAAAJ,EAAEG,SAASC,QAAQ,OACzB,OAAQ,EAAAJ,EAAEG,SAASC,QAAQ,SAE1BC,SAAS,CAAC,GAEf,SAASC,EAAiBC,GACtB,MAAO,CACHC,KAAM,SAASD,EAAKC,OACpBC,SAAUC,UACN,GAAIC,iBAAiBC,SAASL,EAAKC,MAC/B,aAEkBK,gBAAgBN,EAAKC,KAAMD,EAAKO,UAKtDC,WAAWR,EAAKC,MAChBQ,OAAOC,QAAQ,SAASV,EAAKC,aAJzBQ,OAAOE,MAAM,kBAO7B,CACA,SAASC,EAAkBZ,GACvB,MAAO,CACHC,KAAM,OACNC,SAAU,KACN,EAAOW,MAAMb,EAAKc,UAAW,CAAEX,OAAO,EAAMY,QAAQ,IAAQC,KAAKC,IAC7DC,YAAYC,iBAAiBF,EAAMC,YAAYE,WAAWC,KAAM,GAAI,CAChEC,WAAW,EACXC,OAAO,EACPC,wBAAwB,OAK5C,CAgBArB,eAAesB,EAAqBC,EAAKC,GACrC,MAAMC,QAAiBC,MAAMH,EAAK,CAAEI,MAAO,aAC3C,GAAIF,EAASG,GAET,MAAgB,SAATJ,EAAkBC,EAASI,OAASJ,EAASK,OAExD,MAAM,IAAIC,MAAM,IAAIN,EAASO,iBAAiBP,EAASI,SAC3D,CAEAI,EAAEC,aAAalC,WCERA,eAAmCmC,EAAkBC,GACtD,QAAcC,yBAA0BF,EAAU,MACpD7B,OAAOE,MAAM,IAAI4B,mBAAuBD,KAAa,QAEzD,CDLIG,CAAoB,QAAS,UElE1BtC,eAA0BuB,GAC/B,MAAMgB,QAAeb,MAAMH,GAC3B,IAAKgB,EAAOX,GACV,OAAO,EAET,MAAMY,QAAoBD,EAAOV,OACjCY,kBAAkBD,EAEpB,CF2DIE,CAAW,wFACX,MAAMC,EAAWpD,EAASmB,MAAMkC,aAAa,CAAEpB,KAAM,YAErD,GADAqB,iBAAiBF,EAAU,CAAEnB,KAAM,WAC/BsB,OAAOC,OAAOJ,GAAUK,KAAKC,IAAUA,GAAmB,QAAVA,GAChD,OAEJ,MAAMtC,QAAkBW,EAAqBqB,EAAS,OAAQ,QACxD9C,EAAO,CACTC,KAAM,GAAG6C,EAAS,QAAUhC,EAAUuC,MAAM,qBAAqB,IAAM,IACvE9C,cAAekB,EAAqBqB,EAAS,KAAM,QACnDhC,aAnCR,IAAyBwC,UAOzBnD,eAAiCH,GAC7B,OAAKI,iBAAiBC,SAASL,EAAKC,MAG7B,GAFI,CAACF,EAAiBC,GAAOY,EAAkBZ,GAG1D,CAyB0BuD,CAAkBvD,GApCxCsD,EAAQE,QAAQC,IACZC,gBAAgBC,eAAeF,EAAOxD,OACtC2D,QAAQD,eAAeF,EAAOxD,MAAOwD,EAAOvD,YAEhD2D,qBAAqBP,EAAQQ,IAAIL,IAAU,CAAGxD,KAAMwD,EAAOxD,KAAM8D,SAAS","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/酒馆助手/自动更新预设/index.ts","src://tavern_helper_template/util/common.ts","src://tavern_helper_template/util/script.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","// TODO: 抽象出其中与其他脚本重复的代码\nimport { checkMinimumVersion } from '@util/common';\nimport { loadReadme } from '@util/script';\nimport { marked } from 'marked';\nconst Settings = z\n    .object({\n    预设名称: z.string().default('未填写'),\n    预设链接: z.string().default('未填写'),\n    更新日志链接: z.string().default('未填写'),\n})\n    .prefault({});\n//----------------------------------------------------------------------------------------------------------------------\nfunction makeUpdatePreset(data) {\n    return {\n        name: `更新预设: ${data.name}`,\n        function: async () => {\n            if (getPresetNames().includes(data.name)) {\n                return;\n            }\n            const success = await importRawPreset(data.name, data.content);\n            if (!success) {\n                toastr.error('更新预设失败, 请刷新重试');\n                return;\n            }\n            loadPreset(data.name);\n            toastr.success(`更新预设 '${data.name}' 成功`);\n        },\n    };\n}\nfunction makeShowChangelog(data) {\n    return {\n        name: '更新日志',\n        function: () => {\n            marked.parse(data.changelog, { async: true, breaks: true }).then(html => {\n                SillyTavern.callGenericPopup(html, SillyTavern.POPUP_TYPE.TEXT, '', {\n                    leftAlign: true,\n                    wider: true,\n                    allowVerticalScrolling: true,\n                });\n            });\n        },\n    };\n}\n//----------------------------------------------------------------------------------------------------------------------\nfunction registerButtons(buttons) {\n    buttons.forEach(button => {\n        eventClearEvent(getButtonEvent(button.name));\n        eventOn(getButtonEvent(button.name), button.function);\n    });\n    replaceScriptButtons(buttons.map(button => ({ name: button.name, visible: true })));\n}\nasync function checkButtonStatus(data) {\n    if (!getPresetNames().includes(data.name)) {\n        return [makeUpdatePreset(data), makeShowChangelog(data)];\n    }\n    return [];\n}\n//----------------------------------------------------------------------------------------------------------------------\nasync function fetchServerWithError(url, type) {\n    const response = await fetch(url, { cache: 'no-cache' });\n    if (response.ok) {\n        // @ts-expect-error 类型正确\n        return type === 'text' ? response.text() : response.blob();\n    }\n    throw new Error(`(${response.status}) ${await response.text()}`);\n}\n//----------------------------------------------------------------------------------------------------------------------\n$(errorCatched(async () => {\n    checkMinimumVersion('4.6.5', '自动更新预设');\n    loadReadme('https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/src/酒馆助手/自动更新预设/README.md');\n    const settings = Settings.parse(getVariables({ type: 'script' }));\n    replaceVariables(settings, { type: 'script' });\n    if (Object.values(settings).some(value => !value || value === '未填写')) {\n        return;\n    }\n    const changelog = await fetchServerWithError(settings.更新日志链接, 'text');\n    const data = {\n        name: `${settings.预设名称}` + (changelog.match(/^##\\s*(.*)\\s*$/m)?.[1] ?? ''),\n        content: await fetchServerWithError(settings.预设链接, 'text'),\n        changelog,\n    };\n    registerButtons(await checkButtonStatus(data));\n}));\n","import { compare } from 'compare-versions';\nimport JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { toDotPath } from 'zod/v4/core';\n\nexport function assignInplace<T>(destination: T[], new_array: T[]): T[] {\n  destination.length = 0;\n  destination.push(...new_array);\n  return destination;\n}\n\n// 修正 _.merge 对数组的合并逻辑, [1, 2, 3] 和 [4, 5] 合并后变成 [4, 5] 而不是 [4, 5, 3]\nexport function correctlyMerge<TObject, TSource>(lhs: TObject, rhs: TSource): TObject & TSource {\n    return _.mergeWith(lhs, rhs, (_lhs, rhs) => (_.isArray(rhs) ? rhs : undefined));\n}\n\nexport function chunkBy<T>(array: T[], predicate: (lhs: T, rhs: T) => boolean): T[][] {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const chunks: T[][] = [[array[0]]];\n  for (const [lhs, rhs] of _.zip(_.dropRight(array), _.drop(array))) {\n    if (predicate(lhs!, rhs!)) {\n      chunks[chunks.length - 1].push(rhs!);\n    } else {\n      chunks.push([rhs!]);\n    }\n  }\n  return chunks;\n}\n\nexport function regexFromString(input: string, replace_macros?: boolean): RegExp | null {\n  if (!input) {\n    return null;\n  }\n  const makeRegex = (pattern: string, flags: string) => {\n    if (replace_macros) {\n      pattern = substitudeMacros(pattern);\n    }\n    return new RegExp(pattern, flags);\n  };\n  try {\n    const match = input.match(/\\/(.+)\\/([a-z]*)/i);\n    if (!match) {\n      return makeRegex(_.escapeRegExp(input), 'i');\n    }\n    if (match[2] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(match[3])) {\n      return makeRegex(input, 'i');\n    }\n    let flags = match[2] ?? '';\n    _.pull(flags, 'g');\n    if (flags.indexOf('i') === -1) {\n      flags = flags + 'i';\n    }\n    return makeRegex(match[1], flags);\n  } catch {\n    return null;\n  }\n}\n\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function checkMinimumVersion(expected: string, title: string) {\n  if (compare(await getTavernHelperVersion(), expected, '<')) {\n    toastr.error(`'${title}' 需要酒馆助手版本 >= '${expected}'`, '版本不兼容');\n  }\n}\n\nexport function prettifyErrorWithInput(error: z.ZodError) {\n  return _([...error.issues])\n    .sortBy(issue => issue.path?.length ?? 0)\n    .flatMap(issue => {\n      const lines = [`✖ ${issue.message}`];\n      if (issue.path?.length) {\n        lines.push(`  → 路径: ${toDotPath(issue.path)}`);\n      }\n      if (issue.input !== undefined) {\n        lines.push(`  → 输入: ${JSON.stringify(issue.input)}`);\n      }\n      return lines;\n    })\n    .join('\\n');\n}\n\nexport function literalYamlify(value: any) {\n  return YAML.stringify(value, { blockQuote: 'literal' });\n}\n\nexport function parseString(content: string): any {\n  let parsed: unknown;\n  try {\n    parsed = YAML.parseDocument(content, { merge: true }).toJS();\n  } catch (yaml_error) {\n    try {\n      // eslint-disable-next-line import-x/no-named-as-default-member\n      parsed = JSON5.parse(content);\n    } catch (json5_error) {\n      try {\n        parsed = JSON.parse(jsonrepair(content));\n      } catch (json_error) {\n        const toError = (error: unknown) => (error instanceof Error ? error.message : String(error));\n        throw new Error(\n          literalYamlify({\n            ['要解析的字符串不是有效的 YAML/JSON 格式']: {\n              字符串内容: content,\n              YAML错误信息: toError(yaml_error),\n              JSON5错误信息: toError(json5_error),\n              尝试修复JSON时的错误信息: toError(json_error),\n            },\n          }),\n        );\n      }\n    }\n  }\n  return parsed;\n}\n\nexport function getComplementString(string: string) {\n  const encoder = new TextEncoder();\n  const bytes = encoder.encode(string);\n\n  const complemented = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    complemented[i] = 0xff - bytes[i];\n  }\n\n  let hex = '';\n  for (let i = 0; i < complemented.length; i++) {\n    const h = complemented[i].toString(16).padStart(2, '0');\n    hex += h;\n  }\n  return hex;\n}\n\nexport async function checkAndUpdateCharacter(name: string, latest_version: string, png_url: string): Promise<void> {\n  const current_version = (await getCharacter(name)).version.trim() || '0.0.0';\n  if (compare(current_version, latest_version, '>=')) {\n    return;\n  }\n  await importRawCharacter(name, await fetch(png_url).then(response => response.blob()));\n  replaceCharacter(name, { version: latest_version });\n  toastr.success(\n    `角色卡已自动更新到 '${latest_version.startsWith('v') ? latest_version : `v${latest_version}`}'`,\n    name,\n  );\n}\n","import iframe_srcdoc from './iframe_srcdoc.html';\n\nexport async function loadReadme(url: string): Promise<boolean> {\n  const readme = await fetch(url);\n  if (!readme.ok) {\n    return false;\n  }\n  const readme_text = await readme.text();\n  replaceScriptInfo(readme_text);\n  return true;\n}\n\nexport function teleportStyle(\n  append_to: JQuery.Selector | JQuery.htmlString | JQuery.TypeOrArray<Element | DocumentFragment> | JQuery = 'head',\n): { destroy: () => void } {\n  const $div = $(`<div>`)\n    .attr('script_id', getScriptId())\n    .append($(`head > style`, document).clone())\n    .appendTo(append_to);\n\n  return {\n    destroy: () => $div.remove(),\n  };\n}\n\nexport function createScriptIdIframe(): JQuery<HTMLIFrameElement> {\n  return $(`<iframe>`).attr({\n    script_id: getScriptId(),\n    frameborder: 0,\n    srcdoc: iframe_srcdoc,\n  }) as JQuery<HTMLIFrameElement>;\n}\n\nexport function createScriptIdDiv(): JQuery<HTMLDivElement> {\n  return $('<div>').attr('script_id', getScriptId()) as JQuery<HTMLDivElement>;\n}\n\nexport function reloadOnChatChange(): EventOnReturn {\n  let chat_id = SillyTavern.getCurrentChatId();\n  return eventOn(tavern_events.CHAT_CHANGED, new_chat_id => {\n    if (chat_id !== new_chat_id) {\n      chat_id = new_chat_id;\n      window.location.reload();\n    }\n  });\n}\n\nexport function registerAsUniqueScript(id: string): {\n  unregister: () => void;\n  getPreferredScriptId: () => string | undefined;\n  listenPreferenceState: (callback: (perferred_script_id: string) => void) => EventOnReturn;\n} {\n  const script_id = getScriptId();\n  const path = `th_unique_check.${id}`;\n\n  const getPreferredScriptId = () => {\n    const registered_scripts = _.get(window.parent, path, new Set<string>());\n    return _($('#tavern_helper').find('div[data-script-id]').toArray())\n      .map(element => String($(element).attr('data-script-id')))\n      .filter(element => registered_scripts.has(element))\n      .last();\n  };\n\n  _.update(window.parent, path, (value: Set<string> | undefined) => {\n    if (value === undefined) {\n      return new Set([script_id]);\n    }\n    value.add(script_id);\n    return value;\n  });\n  eventEmit(path, getPreferredScriptId());\n\n  return {\n    unregister: () => {\n      _.update(window.parent, path, (value: Set<string> | undefined) => {\n        if (value !== undefined) {\n          value.delete(script_id);\n        }\n        return value;\n      });\n      eventEmit(path, getPreferredScriptId());\n    },\n    getPreferredScriptId,\n    listenPreferenceState: (callback: (enabled_script_id: string) => void) => eventOn(path, callback),\n  };\n}\n"],"names":["z","Settings","object","string","default","prefault","makeUpdatePreset","data","name","function","async","getPresetNames","includes","importRawPreset","content","loadPreset","toastr","success","error","makeShowChangelog","parse","changelog","breaks","then","html","SillyTavern","callGenericPopup","POPUP_TYPE","TEXT","leftAlign","wider","allowVerticalScrolling","fetchServerWithError","url","type","response","fetch","cache","ok","text","blob","Error","status","$","errorCatched","expected","title","getTavernHelperVersion","checkMinimumVersion","readme","readme_text","replaceScriptInfo","loadReadme","settings","getVariables","replaceVariables","Object","values","some","value","match","buttons","checkButtonStatus","forEach","button","eventClearEvent","getButtonEvent","eventOn","replaceScriptButtons","map","visible"],"sourceRoot":""}