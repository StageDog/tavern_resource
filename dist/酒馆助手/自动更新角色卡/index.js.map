{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/external var \"z\"","src://tavern_helper_template/src/酒馆助手/自动更新角色卡/index.ts","src://tavern_helper_template/util/common.ts","src://tavern_helper_template/util/script.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = z;","// TODO: 抽象出其中与其他脚本重复的代码\nimport { checkMinimumVersion } from '@util/common';\nimport { loadReadme } from '@util/script';\nimport { compare } from 'compare-versions';\nimport { marked } from 'marked';\nconst Settings = z\n    .object({\n    角色卡名称: z.string().default('未填写'),\n    角色卡链接: z.string().default('未填写'),\n    更新日志链接: z.string().default('未填写'),\n})\n    .prefault({});\n//----------------------------------------------------------------------------------------------------------------------\nfunction makeUpdateCharacter(data) {\n    return {\n        name: `更新角色卡: ${data.name}${data.version}`,\n        function: async () => {\n            const primary = getCharWorldbookNames('current').primary;\n            if (primary) {\n                const result = await SillyTavern.callGenericPopup('更新角色卡将会覆盖掉现在的世界书, 你需要备份吗?', SillyTavern.POPUP_TYPE.CONFIRM, '', {\n                    leftAlign: true,\n                    customButtons: ['备份并更新'],\n                    okButton: '仅更新',\n                    cancelButton: '取消',\n                    wide: true,\n                });\n                if (!result) {\n                    return;\n                }\n                if (result === 2) {\n                    const backup = `${primary} (备份)`;\n                    const success = await createOrReplaceWorldbook(backup, await getWorldbook(primary));\n                    if (success) {\n                        toastr.success(`已将世界书备份为 '${backup}'`);\n                    }\n                }\n            }\n            const success = await importRawCharacter(data.name, data.content);\n            if (!success) {\n                toastr.error('更新角色卡失败, 请刷新重试');\n                return;\n            }\n            replaceCharacter(data.name, { version: data.version });\n            toastr.success(`更新角色卡 '${data.name}' 成功`);\n        },\n    };\n}\nfunction makeShowChangelog(data) {\n    return {\n        name: '更新日志',\n        function: () => {\n            marked.parse(data.changelog, { async: true, breaks: true }).then(html => {\n                SillyTavern.callGenericPopup(html, SillyTavern.POPUP_TYPE.TEXT, '', {\n                    leftAlign: true,\n                    wider: true,\n                    allowVerticalScrolling: true,\n                });\n            });\n        },\n    };\n}\n//----------------------------------------------------------------------------------------------------------------------\nasync function updateButtons(data) {\n    const current_version = await getCharacter(data.name)\n        .then(character => character.version.trim() || '0.0.0')\n        .catch(() => '0.0.0');\n    let should_update = false;\n    try {\n        should_update = current_version !== data.version || compare(current_version, data.version, '<');\n    }\n    catch (error) {\n        /** ignore */\n    }\n    const buttons = [makeUpdateCharacter(data), makeShowChangelog(data)];\n    if (should_update) {\n        buttons.forEach(button => {\n            eventClearEvent(getButtonEvent(button.name));\n            eventOn(getButtonEvent(button.name), button.function);\n        });\n        replaceScriptButtons(_(getScriptButtons())\n            .filter(button => buttons.every(b => b.name !== button.name))\n            .concat(buttons.map(button => ({ name: button.name, visible: true })))\n            .value());\n        return;\n    }\n    buttons.forEach(button => {\n        eventClearEvent(getButtonEvent(button.name));\n    });\n    replaceScriptButtons(_(getScriptButtons())\n        .filter(button => buttons.every(b => b.name !== button.name))\n        .value());\n}\n//----------------------------------------------------------------------------------------------------------------------\nasync function fetchServerWithError(url, type) {\n    const response = await fetch(url, { cache: 'no-cache' });\n    if (response.ok) {\n        // @ts-expect-error 类型正确\n        return type === 'text' ? response.text() : response.blob();\n    }\n    throw new Error(`(${response.status}) ${await response.text()}`);\n}\n//----------------------------------------------------------------------------------------------------------------------\n$(errorCatched(async () => {\n    checkMinimumVersion('4.6.5', '自动更新角色卡');\n    loadReadme('https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/src/酒馆助手/自动更新角色卡/README.md');\n    const settings = Settings.parse(getVariables({ type: 'script' }));\n    replaceVariables(settings, { type: 'script' });\n    if (Object.values(settings).some(value => !value || value === '未填写')) {\n        return;\n    }\n    const changelog = await fetchServerWithError(settings.更新日志链接, 'text');\n    const data = {\n        name: settings.角色卡名称,\n        version: changelog.match(/^##\\s*(.*)\\s*$/m)?.[1] ?? '',\n        content: await fetchServerWithError(settings.角色卡链接, 'blob'),\n        changelog: changelog,\n    };\n    await updateButtons(data);\n}));\n","import { compare } from 'compare-versions';\nimport JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { toDotPath } from 'zod/v4/core';\n\nexport function assignInplace<T>(destination: T[], new_array: T[]): T[] {\n  destination.length = 0;\n  destination.push(...new_array);\n  return destination;\n}\n\n// 修正 _.merge 对数组的合并逻辑, [1, 2, 3] 和 [4, 5] 合并后变成 [4, 5] 而不是 [4, 5, 3]\nexport function correctlyMerge<TObject, TSource>(lhs: TObject, rhs: TSource): TObject & TSource {\n  return _.mergeWith(lhs, rhs, (_lhs, rhs) => (_.isArray(rhs) ? rhs : undefined));\n}\n\nexport function chunkBy<T>(array: T[], predicate: (lhs: T, rhs: T) => boolean): T[][] {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const chunks: T[][] = [[array[0]]];\n  for (const [lhs, rhs] of _.zip(_.dropRight(array), _.drop(array))) {\n    if (predicate(lhs!, rhs!)) {\n      chunks[chunks.length - 1].push(rhs!);\n    } else {\n      chunks.push([rhs!]);\n    }\n  }\n  return chunks;\n}\n\nexport function regexFromString(input: string, replace_macros?: boolean): RegExp | null {\n  if (!input) {\n    return null;\n  }\n  const makeRegex = (pattern: string, flags: string) => {\n    if (replace_macros) {\n      pattern = substitudeMacros(pattern);\n    }\n    return new RegExp(pattern, flags);\n  };\n  try {\n    const match = input.match(/\\/(.+)\\/([a-z]*)/i);\n    if (!match) {\n      return makeRegex(_.escapeRegExp(input), 'i');\n    }\n    if (match[2] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(match[3])) {\n      return makeRegex(input, 'i');\n    }\n    let flags = match[2] ?? '';\n    _.pull(flags, 'g');\n    if (flags.indexOf('i') === -1) {\n      flags = flags + 'i';\n    }\n    return makeRegex(match[1], flags);\n  } catch {\n    return null;\n  }\n}\n\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function checkMinimumVersion(expected: string, title: string) {\n  if (compare(await getTavernHelperVersion(), expected, '<')) {\n    toastr.error(`'${title}' 需要酒馆助手版本 >= '${expected}'`, '版本不兼容');\n  }\n}\n\nexport function prettifyErrorWithInput(error: z.ZodError) {\n  return _([...error.issues])\n    .sortBy(issue => issue.path?.length ?? 0)\n    .flatMap(issue => {\n      const lines = [`✖ ${issue.message}`];\n      if (issue.path?.length) {\n        lines.push(`  → 路径: ${toDotPath(issue.path)}`);\n      }\n      if (issue.input !== undefined) {\n        lines.push(`  → 输入: ${JSON.stringify(issue.input)}`);\n      }\n      return lines;\n    })\n    .join('\\n');\n}\n\nexport function literalYamlify(value: any) {\n  return YAML.stringify(value, { blockQuote: 'literal' });\n}\n\nexport function parseString(content: string): any {\n  let parsed: unknown;\n  try {\n    parsed = YAML.parseDocument(content, { merge: true }).toJS();\n  } catch (yaml_error) {\n    try {\n      // eslint-disable-next-line import-x/no-named-as-default-member\n      parsed = JSON5.parse(content);\n    } catch (json5_error) {\n      try {\n        parsed = JSON.parse(jsonrepair(content));\n      } catch (json_error) {\n        const toError = (error: unknown) => (error instanceof Error ? error.message : String(error));\n        throw new Error(\n          literalYamlify({\n            ['要解析的字符串不是有效的 YAML/JSON 格式']: {\n              字符串内容: content,\n              YAML错误信息: toError(yaml_error),\n              JSON5错误信息: toError(json5_error),\n              尝试修复JSON时的错误信息: toError(json_error),\n            },\n          }),\n        );\n      }\n    }\n  }\n  return parsed;\n}\n\nexport function getComplementString(string: string) {\n  const encoder = new TextEncoder();\n  const bytes = encoder.encode(string);\n\n  const complemented = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    complemented[i] = 0xff - bytes[i];\n  }\n\n  let hex = '';\n  for (let i = 0; i < complemented.length; i++) {\n    const h = complemented[i].toString(16).padStart(2, '0');\n    hex += h;\n  }\n  return hex;\n}\n","import iframe_srcdoc from './iframe_srcdoc.html';\n\nexport async function loadReadme(url: string): Promise<boolean> {\n  const readme = await fetch(url);\n  if (!readme.ok) {\n    return false;\n  }\n  const readme_text = await readme.text();\n  replaceScriptInfo(readme_text);\n  return true;\n}\n\nexport function teleportStyle(\n  append_to: JQuery.Selector | JQuery.htmlString | JQuery.TypeOrArray<Element | DocumentFragment> | JQuery = 'head',\n): { destroy: () => void } {\n  const $div = $(`<div>`)\n    .attr('script_id', getScriptId())\n    .append($(`head > style`, document).clone())\n    .appendTo(append_to);\n\n  return {\n    destroy: () => $div.remove(),\n  };\n}\n\nexport function createScriptIdIframe(): JQuery<HTMLIFrameElement> {\n  return $(`<iframe>`).attr({\n    script_id: getScriptId(),\n    frameborder: 0,\n    srcdoc: iframe_srcdoc,\n  }) as JQuery<HTMLIFrameElement>;\n}\n\nexport function createScriptIdDiv(): JQuery<HTMLDivElement> {\n  return $('<div>').attr('script_id', getScriptId()) as JQuery<HTMLDivElement>;\n}\n\nexport function reloadOnChatChange(): EventOnReturn {\n  let chat_id = SillyTavern.getCurrentChatId();\n  return eventOn(tavern_events.CHAT_CHANGED, new_chat_id => {\n    if (chat_id !== new_chat_id) {\n      chat_id = new_chat_id;\n      window.location.reload();\n    }\n  });\n}\n\nexport function registerAsUniqueScript(id: string): {\n  unregister: () => void;\n  getPreferredScriptId: () => string | undefined;\n  listenPreferenceState: (callback: (perferred_script_id: string) => void) => EventOnReturn;\n} {\n  const script_id = getScriptId();\n  const path = `th_unique_check.${id}`;\n\n  const getPreferredScriptId = () => {\n    const registered_scripts = _.get(window.parent, path, new Set<string>());\n    return _($('#tavern_helper').find('div[data-script-id]').toArray())\n      .map(element => String($(element).attr('data-script-id')))\n      .filter(element => registered_scripts.has(element))\n      .last();\n  };\n\n  _.update(window.parent, path, (value: Set<string> | undefined) => {\n    if (value === undefined) {\n      return new Set([script_id]);\n    }\n    value.add(script_id);\n    return value;\n  });\n  eventEmit(path, getPreferredScriptId());\n\n  return {\n    unregister: () => {\n      _.update(window.parent, path, (value: Set<string> | undefined) => {\n        if (value !== undefined) {\n          value.delete(script_id);\n        }\n        return value;\n      });\n      eventEmit(path, getPreferredScriptId());\n    },\n    getPreferredScriptId,\n    listenPreferenceState: (callback: (enabled_script_id: string) => void) => eventOn(path, callback),\n  };\n}\n"],"names":["z","Settings","object","string","default","prefault","makeUpdateCharacter","data","name","version","function","async","primary","getCharWorldbookNames","result","SillyTavern","callGenericPopup","POPUP_TYPE","CONFIRM","leftAlign","customButtons","okButton","cancelButton","wide","backup","createOrReplaceWorldbook","getWorldbook","toastr","success","importRawCharacter","content","replaceCharacter","error","makeShowChangelog","parse","changelog","breaks","then","html","TEXT","wider","allowVerticalScrolling","fetchServerWithError","url","type","response","fetch","cache","ok","text","blob","Error","status","$","errorCatched","expected","title","getTavernHelperVersion","checkMinimumVersion","readme","readme_text","replaceScriptInfo","loadReadme","settings","getVariables","replaceVariables","Object","values","some","value","match","current_version","getCharacter","character","trim","catch","should_update","buttons","forEach","button","eventClearEvent","getButtonEvent","eventOn","replaceScriptButtons","_","getScriptButtons","filter","every","b","concat","map","visible","updateButtons"],"sourceRoot":""}